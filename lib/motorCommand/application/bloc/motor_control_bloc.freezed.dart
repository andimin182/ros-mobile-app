// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'motor_control_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$MotorControlEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() moveForward,
    required TResult Function() moveBackward,
    required TResult Function() turnLeft,
    required TResult Function() turnRight,
    required TResult Function() stop,
    required TResult Function() connect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? moveForward,
    TResult? Function()? moveBackward,
    TResult? Function()? turnLeft,
    TResult? Function()? turnRight,
    TResult? Function()? stop,
    TResult? Function()? connect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? moveForward,
    TResult Function()? moveBackward,
    TResult Function()? turnLeft,
    TResult Function()? turnRight,
    TResult Function()? stop,
    TResult Function()? connect,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MoveForward value) moveForward,
    required TResult Function(_MoveBackward value) moveBackward,
    required TResult Function(_TurnLeft value) turnLeft,
    required TResult Function(_TurnRight value) turnRight,
    required TResult Function(_Stop value) stop,
    required TResult Function(_Connect value) connect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MoveForward value)? moveForward,
    TResult? Function(_MoveBackward value)? moveBackward,
    TResult? Function(_TurnLeft value)? turnLeft,
    TResult? Function(_TurnRight value)? turnRight,
    TResult? Function(_Stop value)? stop,
    TResult? Function(_Connect value)? connect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MoveForward value)? moveForward,
    TResult Function(_MoveBackward value)? moveBackward,
    TResult Function(_TurnLeft value)? turnLeft,
    TResult Function(_TurnRight value)? turnRight,
    TResult Function(_Stop value)? stop,
    TResult Function(_Connect value)? connect,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MotorControlEventCopyWith<$Res> {
  factory $MotorControlEventCopyWith(
          MotorControlEvent value, $Res Function(MotorControlEvent) then) =
      _$MotorControlEventCopyWithImpl<$Res, MotorControlEvent>;
}

/// @nodoc
class _$MotorControlEventCopyWithImpl<$Res, $Val extends MotorControlEvent>
    implements $MotorControlEventCopyWith<$Res> {
  _$MotorControlEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_MoveForwardCopyWith<$Res> {
  factory _$$_MoveForwardCopyWith(
          _$_MoveForward value, $Res Function(_$_MoveForward) then) =
      __$$_MoveForwardCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MoveForwardCopyWithImpl<$Res>
    extends _$MotorControlEventCopyWithImpl<$Res, _$_MoveForward>
    implements _$$_MoveForwardCopyWith<$Res> {
  __$$_MoveForwardCopyWithImpl(
      _$_MoveForward _value, $Res Function(_$_MoveForward) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_MoveForward implements _MoveForward {
  const _$_MoveForward();

  @override
  String toString() {
    return 'MotorControlEvent.moveForward()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_MoveForward);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() moveForward,
    required TResult Function() moveBackward,
    required TResult Function() turnLeft,
    required TResult Function() turnRight,
    required TResult Function() stop,
    required TResult Function() connect,
  }) {
    return moveForward();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? moveForward,
    TResult? Function()? moveBackward,
    TResult? Function()? turnLeft,
    TResult? Function()? turnRight,
    TResult? Function()? stop,
    TResult? Function()? connect,
  }) {
    return moveForward?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? moveForward,
    TResult Function()? moveBackward,
    TResult Function()? turnLeft,
    TResult Function()? turnRight,
    TResult Function()? stop,
    TResult Function()? connect,
    required TResult orElse(),
  }) {
    if (moveForward != null) {
      return moveForward();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MoveForward value) moveForward,
    required TResult Function(_MoveBackward value) moveBackward,
    required TResult Function(_TurnLeft value) turnLeft,
    required TResult Function(_TurnRight value) turnRight,
    required TResult Function(_Stop value) stop,
    required TResult Function(_Connect value) connect,
  }) {
    return moveForward(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MoveForward value)? moveForward,
    TResult? Function(_MoveBackward value)? moveBackward,
    TResult? Function(_TurnLeft value)? turnLeft,
    TResult? Function(_TurnRight value)? turnRight,
    TResult? Function(_Stop value)? stop,
    TResult? Function(_Connect value)? connect,
  }) {
    return moveForward?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MoveForward value)? moveForward,
    TResult Function(_MoveBackward value)? moveBackward,
    TResult Function(_TurnLeft value)? turnLeft,
    TResult Function(_TurnRight value)? turnRight,
    TResult Function(_Stop value)? stop,
    TResult Function(_Connect value)? connect,
    required TResult orElse(),
  }) {
    if (moveForward != null) {
      return moveForward(this);
    }
    return orElse();
  }
}

abstract class _MoveForward implements MotorControlEvent {
  const factory _MoveForward() = _$_MoveForward;
}

/// @nodoc
abstract class _$$_MoveBackwardCopyWith<$Res> {
  factory _$$_MoveBackwardCopyWith(
          _$_MoveBackward value, $Res Function(_$_MoveBackward) then) =
      __$$_MoveBackwardCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MoveBackwardCopyWithImpl<$Res>
    extends _$MotorControlEventCopyWithImpl<$Res, _$_MoveBackward>
    implements _$$_MoveBackwardCopyWith<$Res> {
  __$$_MoveBackwardCopyWithImpl(
      _$_MoveBackward _value, $Res Function(_$_MoveBackward) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_MoveBackward implements _MoveBackward {
  const _$_MoveBackward();

  @override
  String toString() {
    return 'MotorControlEvent.moveBackward()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_MoveBackward);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() moveForward,
    required TResult Function() moveBackward,
    required TResult Function() turnLeft,
    required TResult Function() turnRight,
    required TResult Function() stop,
    required TResult Function() connect,
  }) {
    return moveBackward();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? moveForward,
    TResult? Function()? moveBackward,
    TResult? Function()? turnLeft,
    TResult? Function()? turnRight,
    TResult? Function()? stop,
    TResult? Function()? connect,
  }) {
    return moveBackward?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? moveForward,
    TResult Function()? moveBackward,
    TResult Function()? turnLeft,
    TResult Function()? turnRight,
    TResult Function()? stop,
    TResult Function()? connect,
    required TResult orElse(),
  }) {
    if (moveBackward != null) {
      return moveBackward();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MoveForward value) moveForward,
    required TResult Function(_MoveBackward value) moveBackward,
    required TResult Function(_TurnLeft value) turnLeft,
    required TResult Function(_TurnRight value) turnRight,
    required TResult Function(_Stop value) stop,
    required TResult Function(_Connect value) connect,
  }) {
    return moveBackward(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MoveForward value)? moveForward,
    TResult? Function(_MoveBackward value)? moveBackward,
    TResult? Function(_TurnLeft value)? turnLeft,
    TResult? Function(_TurnRight value)? turnRight,
    TResult? Function(_Stop value)? stop,
    TResult? Function(_Connect value)? connect,
  }) {
    return moveBackward?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MoveForward value)? moveForward,
    TResult Function(_MoveBackward value)? moveBackward,
    TResult Function(_TurnLeft value)? turnLeft,
    TResult Function(_TurnRight value)? turnRight,
    TResult Function(_Stop value)? stop,
    TResult Function(_Connect value)? connect,
    required TResult orElse(),
  }) {
    if (moveBackward != null) {
      return moveBackward(this);
    }
    return orElse();
  }
}

abstract class _MoveBackward implements MotorControlEvent {
  const factory _MoveBackward() = _$_MoveBackward;
}

/// @nodoc
abstract class _$$_TurnLeftCopyWith<$Res> {
  factory _$$_TurnLeftCopyWith(
          _$_TurnLeft value, $Res Function(_$_TurnLeft) then) =
      __$$_TurnLeftCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_TurnLeftCopyWithImpl<$Res>
    extends _$MotorControlEventCopyWithImpl<$Res, _$_TurnLeft>
    implements _$$_TurnLeftCopyWith<$Res> {
  __$$_TurnLeftCopyWithImpl(
      _$_TurnLeft _value, $Res Function(_$_TurnLeft) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_TurnLeft implements _TurnLeft {
  const _$_TurnLeft();

  @override
  String toString() {
    return 'MotorControlEvent.turnLeft()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_TurnLeft);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() moveForward,
    required TResult Function() moveBackward,
    required TResult Function() turnLeft,
    required TResult Function() turnRight,
    required TResult Function() stop,
    required TResult Function() connect,
  }) {
    return turnLeft();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? moveForward,
    TResult? Function()? moveBackward,
    TResult? Function()? turnLeft,
    TResult? Function()? turnRight,
    TResult? Function()? stop,
    TResult? Function()? connect,
  }) {
    return turnLeft?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? moveForward,
    TResult Function()? moveBackward,
    TResult Function()? turnLeft,
    TResult Function()? turnRight,
    TResult Function()? stop,
    TResult Function()? connect,
    required TResult orElse(),
  }) {
    if (turnLeft != null) {
      return turnLeft();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MoveForward value) moveForward,
    required TResult Function(_MoveBackward value) moveBackward,
    required TResult Function(_TurnLeft value) turnLeft,
    required TResult Function(_TurnRight value) turnRight,
    required TResult Function(_Stop value) stop,
    required TResult Function(_Connect value) connect,
  }) {
    return turnLeft(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MoveForward value)? moveForward,
    TResult? Function(_MoveBackward value)? moveBackward,
    TResult? Function(_TurnLeft value)? turnLeft,
    TResult? Function(_TurnRight value)? turnRight,
    TResult? Function(_Stop value)? stop,
    TResult? Function(_Connect value)? connect,
  }) {
    return turnLeft?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MoveForward value)? moveForward,
    TResult Function(_MoveBackward value)? moveBackward,
    TResult Function(_TurnLeft value)? turnLeft,
    TResult Function(_TurnRight value)? turnRight,
    TResult Function(_Stop value)? stop,
    TResult Function(_Connect value)? connect,
    required TResult orElse(),
  }) {
    if (turnLeft != null) {
      return turnLeft(this);
    }
    return orElse();
  }
}

abstract class _TurnLeft implements MotorControlEvent {
  const factory _TurnLeft() = _$_TurnLeft;
}

/// @nodoc
abstract class _$$_TurnRightCopyWith<$Res> {
  factory _$$_TurnRightCopyWith(
          _$_TurnRight value, $Res Function(_$_TurnRight) then) =
      __$$_TurnRightCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_TurnRightCopyWithImpl<$Res>
    extends _$MotorControlEventCopyWithImpl<$Res, _$_TurnRight>
    implements _$$_TurnRightCopyWith<$Res> {
  __$$_TurnRightCopyWithImpl(
      _$_TurnRight _value, $Res Function(_$_TurnRight) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_TurnRight implements _TurnRight {
  const _$_TurnRight();

  @override
  String toString() {
    return 'MotorControlEvent.turnRight()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_TurnRight);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() moveForward,
    required TResult Function() moveBackward,
    required TResult Function() turnLeft,
    required TResult Function() turnRight,
    required TResult Function() stop,
    required TResult Function() connect,
  }) {
    return turnRight();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? moveForward,
    TResult? Function()? moveBackward,
    TResult? Function()? turnLeft,
    TResult? Function()? turnRight,
    TResult? Function()? stop,
    TResult? Function()? connect,
  }) {
    return turnRight?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? moveForward,
    TResult Function()? moveBackward,
    TResult Function()? turnLeft,
    TResult Function()? turnRight,
    TResult Function()? stop,
    TResult Function()? connect,
    required TResult orElse(),
  }) {
    if (turnRight != null) {
      return turnRight();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MoveForward value) moveForward,
    required TResult Function(_MoveBackward value) moveBackward,
    required TResult Function(_TurnLeft value) turnLeft,
    required TResult Function(_TurnRight value) turnRight,
    required TResult Function(_Stop value) stop,
    required TResult Function(_Connect value) connect,
  }) {
    return turnRight(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MoveForward value)? moveForward,
    TResult? Function(_MoveBackward value)? moveBackward,
    TResult? Function(_TurnLeft value)? turnLeft,
    TResult? Function(_TurnRight value)? turnRight,
    TResult? Function(_Stop value)? stop,
    TResult? Function(_Connect value)? connect,
  }) {
    return turnRight?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MoveForward value)? moveForward,
    TResult Function(_MoveBackward value)? moveBackward,
    TResult Function(_TurnLeft value)? turnLeft,
    TResult Function(_TurnRight value)? turnRight,
    TResult Function(_Stop value)? stop,
    TResult Function(_Connect value)? connect,
    required TResult orElse(),
  }) {
    if (turnRight != null) {
      return turnRight(this);
    }
    return orElse();
  }
}

abstract class _TurnRight implements MotorControlEvent {
  const factory _TurnRight() = _$_TurnRight;
}

/// @nodoc
abstract class _$$_StopCopyWith<$Res> {
  factory _$$_StopCopyWith(_$_Stop value, $Res Function(_$_Stop) then) =
      __$$_StopCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_StopCopyWithImpl<$Res>
    extends _$MotorControlEventCopyWithImpl<$Res, _$_Stop>
    implements _$$_StopCopyWith<$Res> {
  __$$_StopCopyWithImpl(_$_Stop _value, $Res Function(_$_Stop) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Stop implements _Stop {
  const _$_Stop();

  @override
  String toString() {
    return 'MotorControlEvent.stop()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Stop);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() moveForward,
    required TResult Function() moveBackward,
    required TResult Function() turnLeft,
    required TResult Function() turnRight,
    required TResult Function() stop,
    required TResult Function() connect,
  }) {
    return stop();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? moveForward,
    TResult? Function()? moveBackward,
    TResult? Function()? turnLeft,
    TResult? Function()? turnRight,
    TResult? Function()? stop,
    TResult? Function()? connect,
  }) {
    return stop?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? moveForward,
    TResult Function()? moveBackward,
    TResult Function()? turnLeft,
    TResult Function()? turnRight,
    TResult Function()? stop,
    TResult Function()? connect,
    required TResult orElse(),
  }) {
    if (stop != null) {
      return stop();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MoveForward value) moveForward,
    required TResult Function(_MoveBackward value) moveBackward,
    required TResult Function(_TurnLeft value) turnLeft,
    required TResult Function(_TurnRight value) turnRight,
    required TResult Function(_Stop value) stop,
    required TResult Function(_Connect value) connect,
  }) {
    return stop(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MoveForward value)? moveForward,
    TResult? Function(_MoveBackward value)? moveBackward,
    TResult? Function(_TurnLeft value)? turnLeft,
    TResult? Function(_TurnRight value)? turnRight,
    TResult? Function(_Stop value)? stop,
    TResult? Function(_Connect value)? connect,
  }) {
    return stop?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MoveForward value)? moveForward,
    TResult Function(_MoveBackward value)? moveBackward,
    TResult Function(_TurnLeft value)? turnLeft,
    TResult Function(_TurnRight value)? turnRight,
    TResult Function(_Stop value)? stop,
    TResult Function(_Connect value)? connect,
    required TResult orElse(),
  }) {
    if (stop != null) {
      return stop(this);
    }
    return orElse();
  }
}

abstract class _Stop implements MotorControlEvent {
  const factory _Stop() = _$_Stop;
}

/// @nodoc
abstract class _$$_ConnectCopyWith<$Res> {
  factory _$$_ConnectCopyWith(
          _$_Connect value, $Res Function(_$_Connect) then) =
      __$$_ConnectCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ConnectCopyWithImpl<$Res>
    extends _$MotorControlEventCopyWithImpl<$Res, _$_Connect>
    implements _$$_ConnectCopyWith<$Res> {
  __$$_ConnectCopyWithImpl(_$_Connect _value, $Res Function(_$_Connect) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Connect implements _Connect {
  const _$_Connect();

  @override
  String toString() {
    return 'MotorControlEvent.connect()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Connect);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() moveForward,
    required TResult Function() moveBackward,
    required TResult Function() turnLeft,
    required TResult Function() turnRight,
    required TResult Function() stop,
    required TResult Function() connect,
  }) {
    return connect();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? moveForward,
    TResult? Function()? moveBackward,
    TResult? Function()? turnLeft,
    TResult? Function()? turnRight,
    TResult? Function()? stop,
    TResult? Function()? connect,
  }) {
    return connect?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? moveForward,
    TResult Function()? moveBackward,
    TResult Function()? turnLeft,
    TResult Function()? turnRight,
    TResult Function()? stop,
    TResult Function()? connect,
    required TResult orElse(),
  }) {
    if (connect != null) {
      return connect();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MoveForward value) moveForward,
    required TResult Function(_MoveBackward value) moveBackward,
    required TResult Function(_TurnLeft value) turnLeft,
    required TResult Function(_TurnRight value) turnRight,
    required TResult Function(_Stop value) stop,
    required TResult Function(_Connect value) connect,
  }) {
    return connect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MoveForward value)? moveForward,
    TResult? Function(_MoveBackward value)? moveBackward,
    TResult? Function(_TurnLeft value)? turnLeft,
    TResult? Function(_TurnRight value)? turnRight,
    TResult? Function(_Stop value)? stop,
    TResult? Function(_Connect value)? connect,
  }) {
    return connect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MoveForward value)? moveForward,
    TResult Function(_MoveBackward value)? moveBackward,
    TResult Function(_TurnLeft value)? turnLeft,
    TResult Function(_TurnRight value)? turnRight,
    TResult Function(_Stop value)? stop,
    TResult Function(_Connect value)? connect,
    required TResult orElse(),
  }) {
    if (connect != null) {
      return connect(this);
    }
    return orElse();
  }
}

abstract class _Connect implements MotorControlEvent {
  const factory _Connect() = _$_Connect;
}

/// @nodoc
mixin _$MotorControlState {
  bool get isMovingForward => throw _privateConstructorUsedError;
  bool get isMovingBackward => throw _privateConstructorUsedError;
  bool get isTurningLeft => throw _privateConstructorUsedError;
  bool get isTurningRight => throw _privateConstructorUsedError;
  bool get isStop => throw _privateConstructorUsedError;
  bool get isConnected => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MotorControlStateCopyWith<MotorControlState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MotorControlStateCopyWith<$Res> {
  factory $MotorControlStateCopyWith(
          MotorControlState value, $Res Function(MotorControlState) then) =
      _$MotorControlStateCopyWithImpl<$Res, MotorControlState>;
  @useResult
  $Res call(
      {bool isMovingForward,
      bool isMovingBackward,
      bool isTurningLeft,
      bool isTurningRight,
      bool isStop,
      bool isConnected});
}

/// @nodoc
class _$MotorControlStateCopyWithImpl<$Res, $Val extends MotorControlState>
    implements $MotorControlStateCopyWith<$Res> {
  _$MotorControlStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isMovingForward = null,
    Object? isMovingBackward = null,
    Object? isTurningLeft = null,
    Object? isTurningRight = null,
    Object? isStop = null,
    Object? isConnected = null,
  }) {
    return _then(_value.copyWith(
      isMovingForward: null == isMovingForward
          ? _value.isMovingForward
          : isMovingForward // ignore: cast_nullable_to_non_nullable
              as bool,
      isMovingBackward: null == isMovingBackward
          ? _value.isMovingBackward
          : isMovingBackward // ignore: cast_nullable_to_non_nullable
              as bool,
      isTurningLeft: null == isTurningLeft
          ? _value.isTurningLeft
          : isTurningLeft // ignore: cast_nullable_to_non_nullable
              as bool,
      isTurningRight: null == isTurningRight
          ? _value.isTurningRight
          : isTurningRight // ignore: cast_nullable_to_non_nullable
              as bool,
      isStop: null == isStop
          ? _value.isStop
          : isStop // ignore: cast_nullable_to_non_nullable
              as bool,
      isConnected: null == isConnected
          ? _value.isConnected
          : isConnected // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MotorControlStateCopyWith<$Res>
    implements $MotorControlStateCopyWith<$Res> {
  factory _$$_MotorControlStateCopyWith(_$_MotorControlState value,
          $Res Function(_$_MotorControlState) then) =
      __$$_MotorControlStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isMovingForward,
      bool isMovingBackward,
      bool isTurningLeft,
      bool isTurningRight,
      bool isStop,
      bool isConnected});
}

/// @nodoc
class __$$_MotorControlStateCopyWithImpl<$Res>
    extends _$MotorControlStateCopyWithImpl<$Res, _$_MotorControlState>
    implements _$$_MotorControlStateCopyWith<$Res> {
  __$$_MotorControlStateCopyWithImpl(
      _$_MotorControlState _value, $Res Function(_$_MotorControlState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isMovingForward = null,
    Object? isMovingBackward = null,
    Object? isTurningLeft = null,
    Object? isTurningRight = null,
    Object? isStop = null,
    Object? isConnected = null,
  }) {
    return _then(_$_MotorControlState(
      isMovingForward: null == isMovingForward
          ? _value.isMovingForward
          : isMovingForward // ignore: cast_nullable_to_non_nullable
              as bool,
      isMovingBackward: null == isMovingBackward
          ? _value.isMovingBackward
          : isMovingBackward // ignore: cast_nullable_to_non_nullable
              as bool,
      isTurningLeft: null == isTurningLeft
          ? _value.isTurningLeft
          : isTurningLeft // ignore: cast_nullable_to_non_nullable
              as bool,
      isTurningRight: null == isTurningRight
          ? _value.isTurningRight
          : isTurningRight // ignore: cast_nullable_to_non_nullable
              as bool,
      isStop: null == isStop
          ? _value.isStop
          : isStop // ignore: cast_nullable_to_non_nullable
              as bool,
      isConnected: null == isConnected
          ? _value.isConnected
          : isConnected // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_MotorControlState implements _MotorControlState {
  const _$_MotorControlState(
      {required this.isMovingForward,
      required this.isMovingBackward,
      required this.isTurningLeft,
      required this.isTurningRight,
      required this.isStop,
      required this.isConnected});

  @override
  final bool isMovingForward;
  @override
  final bool isMovingBackward;
  @override
  final bool isTurningLeft;
  @override
  final bool isTurningRight;
  @override
  final bool isStop;
  @override
  final bool isConnected;

  @override
  String toString() {
    return 'MotorControlState(isMovingForward: $isMovingForward, isMovingBackward: $isMovingBackward, isTurningLeft: $isTurningLeft, isTurningRight: $isTurningRight, isStop: $isStop, isConnected: $isConnected)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MotorControlState &&
            (identical(other.isMovingForward, isMovingForward) ||
                other.isMovingForward == isMovingForward) &&
            (identical(other.isMovingBackward, isMovingBackward) ||
                other.isMovingBackward == isMovingBackward) &&
            (identical(other.isTurningLeft, isTurningLeft) ||
                other.isTurningLeft == isTurningLeft) &&
            (identical(other.isTurningRight, isTurningRight) ||
                other.isTurningRight == isTurningRight) &&
            (identical(other.isStop, isStop) || other.isStop == isStop) &&
            (identical(other.isConnected, isConnected) ||
                other.isConnected == isConnected));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isMovingForward,
      isMovingBackward, isTurningLeft, isTurningRight, isStop, isConnected);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MotorControlStateCopyWith<_$_MotorControlState> get copyWith =>
      __$$_MotorControlStateCopyWithImpl<_$_MotorControlState>(
          this, _$identity);
}

abstract class _MotorControlState implements MotorControlState {
  const factory _MotorControlState(
      {required final bool isMovingForward,
      required final bool isMovingBackward,
      required final bool isTurningLeft,
      required final bool isTurningRight,
      required final bool isStop,
      required final bool isConnected}) = _$_MotorControlState;

  @override
  bool get isMovingForward;
  @override
  bool get isMovingBackward;
  @override
  bool get isTurningLeft;
  @override
  bool get isTurningRight;
  @override
  bool get isStop;
  @override
  bool get isConnected;
  @override
  @JsonKey(ignore: true)
  _$$_MotorControlStateCopyWith<_$_MotorControlState> get copyWith =>
      throw _privateConstructorUsedError;
}
